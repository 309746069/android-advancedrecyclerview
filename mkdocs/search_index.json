{
    "docs": [
        {
            "location": "/",
            "text": "Advanced RecyclerView\n\u00b6\n\n\n\n\nAdvanded RecyclerView\n is an extension library of the \nRecyclerView\n which brings powerful features, such as Drag & Drop, Swipe, Expand, combining Adapters, etc...\n\n\nDemo app\n\u00b6\n\n\n\n\n\n\n\n\n\nThe above demo video was taken with a very old version of this library \n(v0.6 - Feb 2, 2015)\n. Now the app contains \n26 demos\n! \nLet's give it a try \n\n\n\n\nPhirosophies\n\u00b6\n\n\n\n\n\n\nNever inherit \nRecyclerView\n class\n\n\n\n\nReduces library conflictions, easy to integrate with existing code\n\n\n\n\n\n\n\n\nImplement each features as separated modules\n\n\n\n\nPick features only what you need\n\n\n\n\n\n\n\n\nPrimitive API set rather than user-friendly huge API sets\n\n\n\n\nLooks difficult at a glance, but gives great flexibility like original \nRecyclerView\n\n\n\n\n\n\n\n\nFeatures\n\u00b6\n\n\n\n\nSwipe\n\n\nSwipe dismiss and swipe pinning operation. (like Google's Inbox app)\n\n\n\n\n\n\nDrag and Drop\n\n\nSmooth item reordering with linear list (\nLinearLayoutManager\n). It behaves like the playlist of Google's Play Music app.\n\n\nAlso drag & drop work with \nGridLayoutManager\n and \nStaggeredGridLayoutManager\n.\n\n\n\n\n\n\nExpand\n\n\nA list with collapsible groups and its children. This feature is port of the \nExpandableListView\n of Android framework.\n\n\n\n\n\n\nWrapper adapter\n\n\nInject additional functionalities to \nRecyclerView.Adapter\n by using the \nDecorator patten\n  (Header, Footer, Section, Combining multiple adapters, etc...)\n\n\n\n\n\n\nMisc.\n\n\nAll swipe, drag and drop, expand and wrapper adapter features work together!\n\n\nAn \nItemAnimator\n, it behaves exact the same as the default \nSimpleItemAnimator\n, but its code is refactored. More easy to customize!\n\n\nSome \nItemDecoration\ns. Adding drop shadows to each items, drawing separators.",
            "title": "Home"
        },
        {
            "location": "/#advanced-recyclerview",
            "text": "Advanded RecyclerView  is an extension library of the  RecyclerView  which brings powerful features, such as Drag & Drop, Swipe, Expand, combining Adapters, etc...",
            "title": "Advanced RecyclerView"
        },
        {
            "location": "/#demo-app",
            "text": "The above demo video was taken with a very old version of this library  (v0.6 - Feb 2, 2015) . Now the app contains  26 demos !  Let's give it a try",
            "title": "Demo app"
        },
        {
            "location": "/#phirosophies",
            "text": "Never inherit  RecyclerView  class   Reduces library conflictions, easy to integrate with existing code     Implement each features as separated modules   Pick features only what you need     Primitive API set rather than user-friendly huge API sets   Looks difficult at a glance, but gives great flexibility like original  RecyclerView",
            "title": "Phirosophies"
        },
        {
            "location": "/#features",
            "text": "Swipe  Swipe dismiss and swipe pinning operation. (like Google's Inbox app)    Drag and Drop  Smooth item reordering with linear list ( LinearLayoutManager ). It behaves like the playlist of Google's Play Music app.  Also drag & drop work with  GridLayoutManager  and  StaggeredGridLayoutManager .    Expand  A list with collapsible groups and its children. This feature is port of the  ExpandableListView  of Android framework.    Wrapper adapter  Inject additional functionalities to  RecyclerView.Adapter  by using the  Decorator patten   (Header, Footer, Section, Combining multiple adapters, etc...)    Misc.  All swipe, drag and drop, expand and wrapper adapter features work together!  An  ItemAnimator , it behaves exact the same as the default  SimpleItemAnimator , but its code is refactored. More easy to customize!  Some  ItemDecoration s. Adding drop shadows to each items, drawing separators.",
            "title": "Features"
        },
        {
            "location": "/getting-started/",
            "text": "Installation\n\u00b6\n\n\nAdd the following lines of code into your \nbuild.gradle\n.\n\n\ndependencies\n \n{\n\n    \ncompile\n \n(\n'com.h6ah4i.android.widget.advrecyclerview:advrecyclerview:[VERSION_CODE_GOES_HERE]@aar'\n){\n\n        \ntransitive\n=\ntrue\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNOTE:\n\nThis library is served on \njCenter\n. If the above gradle setting not getting work, try adding the following lines.\n\n\nrepositories\n \n{\n\n    \njcenter\n()\n\n\n}\n\n\n\n\n\n\nWhat's next?\n\u00b6\n\n\nFirst, I recommend you to learn about plain \nRecyclerView\n. Basic knowledges about \nRecyclerView\n are required before using this library. The following tutorial is good for starting point;\n\n\n\n\nCreating Lists and Cards | Android Developers - Training\n\n\n\n\nIf you've already know well about plain \nRecyclerView\n, proceed to each sections written about what you want to use:\n\n\n\n\nWrapper Adapter\n\n\nComposedAdapter\n\n\nHeaders & Footers\n\n\nInsertion & Filtering\n\n\n\n\n\n\nDrag & Drop\n\n\nSwipeable\n\n\nExpandable\n\n\n\n\nOther references\n\u00b6\n\n\n\n\n\n\nDemo app code\n\n\n\n\nInstall the demo app from Google Play\n\n\nCheck the demo app code on GitHub\n\n\n\n\n\n\n\n\nOfficial RecyclerView reference\n\n\n\n\nCreating Lists and Cards --- Android Developers - Training\n\n\nRecyclerView --- Android Developers - Reference\n\n\n\n\n\n\n\n\nCheck the Issues page of Advanced RecyclerView\n\n\n\n\nIssues - Advanced RecyclerView --- GitHub\n\n\n\n\n\n\n\n\nJavadoc\n\n\n\n\nJavadoc - Advanced RecyclerView",
            "title": "Getting Started"
        },
        {
            "location": "/getting-started/#installation",
            "text": "Add the following lines of code into your  build.gradle .  dependencies   { \n     compile   ( 'com.h6ah4i.android.widget.advrecyclerview:advrecyclerview:[VERSION_CODE_GOES_HERE]@aar' ){ \n         transitive = true \n     }  }   NOTE: \nThis library is served on  jCenter . If the above gradle setting not getting work, try adding the following lines.  repositories   { \n     jcenter ()  }",
            "title": "Installation"
        },
        {
            "location": "/getting-started/#whats-next",
            "text": "First, I recommend you to learn about plain  RecyclerView . Basic knowledges about  RecyclerView  are required before using this library. The following tutorial is good for starting point;   Creating Lists and Cards | Android Developers - Training   If you've already know well about plain  RecyclerView , proceed to each sections written about what you want to use:   Wrapper Adapter  ComposedAdapter  Headers & Footers  Insertion & Filtering    Drag & Drop  Swipeable  Expandable",
            "title": "What's next?"
        },
        {
            "location": "/getting-started/#other-references",
            "text": "Demo app code   Install the demo app from Google Play  Check the demo app code on GitHub     Official RecyclerView reference   Creating Lists and Cards --- Android Developers - Training  RecyclerView --- Android Developers - Reference     Check the Issues page of Advanced RecyclerView   Issues - Advanced RecyclerView --- GitHub     Javadoc   Javadoc - Advanced RecyclerView",
            "title": "Other references"
        },
        {
            "location": "/wrapper-adapter/",
            "text": "The \nWrapperAdapter\n is a wrapper of another adapter(s). This is a core mechanism of Advanced RecyclerView library. Drag & Drop, Swipe, Expand, Headers and Footers, etc... major features of this library are using it. We can implement additional functionalities by using \nDecorator pattern\n through the mechanism.\n\n\n\n\nThe \nWrapperAdapter\n is an interface and it is indended to be combined with \nRecyclerView.Adapter\n. The most important role of \nWrapperAdapter\n is converting \nposition\n of items by using \nwrapPosition()\n and \nunwrapPosition()\n methods.\n\n\n\n\nSubclasses:\n\n\n\n\n \nComposedAdapter\n\n\n \nSimpleWrapperAdapter\n\n\n \nAbstractHeaderFooterWrapperAdapter",
            "title": "Wrapper Adapter"
        },
        {
            "location": "/wrapper-adapter/migrate-to-wrapped-adapter/",
            "text": "Tweak your Adapter to support adapter wrapping\n\u00b6\n\n\nNeed to tweak several things in your adapter implemtation to \nsupport wrapping adapter mechanism\n.\nBecause \nWrapperAdapter\n modifies \nitem positions\n, \nitem IDs\n and \nitem view types\n internally.\n\n\n\u00bb If overriding Adapter.getItemId()\n\u00b6\n\n\nThe available range of item ID value is limited, so you cannot use full range of 64-bit integer value.\n Must return a value greather than or equals to \n-(2^55)\n and less than or equals to \n2^55 - 1\n.\n\n\n\n\nNote\n\n\nThis limitation is due to how \nItemIdComposer\n packs other information into 64-bits integer value.\n\n\n\n\n\u00bb If overriding Adapter.getItemViewType()\n\u00b6\n\n\nThe available range of item view type value is limited, so you cannot use full range of 32-bit integer value.\n Must return a value greather than or equals to \n-(2^23)\n and less than or equals to \n2^23 - 1\n.\n\n\n\n\nNote\n\n\nThis limitation is due to how \nItemViewTypeComposer\n packs other information into 32-bits integer value.\n\n\n\n\n\u00bb If using ViewHolder.getAdaperPosition() / ViewHolder.getLayoutPosition())\n\u00b6\n\n\n Use \nWrapperAdapterUtils.unwrapPosition()\n.\n\n\n@Overfides\n\n\nvoid\n \nonClick\n(\nView\n \nv\n)\n \n{\n\n    \nRecyclerView\n \nrv\n \n=\n \nRecyclerViewAdapterUtils\n.\ngetParentRecyclerView\n(\nv\n);\n\n    \nRecyclerView\n.\nViewHolder\n \nvh\n \n=\n \nrv\n.\nfindContainingViewHolder\n(\nv\n);\n\n\n    \nint\n \nrootPosition\n \n=\n \nvh\n.\ngetAdapterPosition\n();\n\n    \nif\n \n(\nrootPosition\n \n==\n \nRecyclerView\n.\nNO_POSITION\n)\n \n{\n\n        \nreturn\n;\n\n    \n}\n\n\n    \n// need to determine adapter local position like this:\n\n    \nRecyclerView\n.\nAdapter\n \nrootAdapter\n \n=\n \nrv\n.\ngetAdapter\n();\n\n    \nint\n \nlocalPosition\n \n=\n \nWrapperAdapterUtils\n.\nunwrapPosition\n(\nrootAdapter\n,\n \nthis\n,\n \nrootPosition\n);\n\n\n    \nItem\n \nitem\n \n=\n \nmItems\n.\nget\n(\nlocalPosition\n);\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\u00bb If using ViewHolder.getItemViewType()\n\u00b6\n\n\n Use \nItemViewTypeComposer.extractWrappedViewTypePart()\n.\n\n\n@Overfides\n\n\nvoid\n \nonClick\n(\nView\n \nv\n)\n \n{\n\n    \nRecyclerView\n.\nViewHolder\n \nvh\n \n=\n \nrecyclerView\n.\nfindContainingViewHolder\n(\nv\n);\n\n\n    \nint\n \nrawViewType\n \n=\n \nvh\n.\ngetItemViewType\n();\n\n    \nint\n \nviewType\n \n=\n \nItemIdComposer\n.\nextractWrappedIdPart\n(\nrawViewType\n);\n\n\n    \n// use \"viewType\" here to determine which type of item is clicked\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\u00bb If using ViewHolder.getItemId()\n\u00b6\n\n\n Use \nItemIdComposer.extractWrappedIdPart()\n.\n\n\n@Overfides\n\n\nvoid\n \nonClick\n(\nView\n \nv\n)\n \n{\n\n    \nRecyclerView\n.\nViewHolder\n \nvh\n \n=\n \nrecyclerView\n.\nfindContainingViewHolder\n(\nv\n);\n\n\n    \nlong\n \nrawId\n \n=\n \nvh\n.\ngetItemId\n();\n\n    \nlong\n \nid\n \n=\n \nItemIdComposer\n.\nextractWrappedIdPart\n(\nrawId\n);\n\n\n    \n// use \"id\" here to determine which item is clicked\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\u00bb If your adapter overrides optional methods of RecyclerView.Adapter\n\u00b6\n\n\n Implement the \nWrappedAdapter\n \n interface and use the \nviewType\n parameter instead of using \nViewHolder.getItemViewType()\n\n\nThis step is only required in case of the adapter overrides the following methods;\n\n\n\n\nonViewAttachedToWindow()\n\n\nonViewDetachedFromWindow()\n\n\nonViewRecycled()\n\n\nonFailedToRecycleView()\n\n\n\n\nclass\n \nMyInnerAdapter\n<\nVH\n>\n \nimplements\n \nWrappedAdapter\n<\nVH\n>\n \n{\n\n    \n// the following four methods are provided by WrappedAdapter interface\n\n    \n@Overrides\n\n    \nvoid\n \nonViewAttachedToWindow\n(\nVH\n \nholder\n,\n \nint\n \nviewType\n)\n \n{\n \n...\n \n}\n\n\n    \n@Overrides\n\n    \nvoid\n \nonViewDetachedFromWindow\n(\nVH\n \nholder\n,\n \nint\n \nviewType\n)\n \n{\n \n...\n \n}\n\n\n    \n@Overrides\n\n    \nvoid\n \nonViewRecycled\n(\nVH\n \nholder\n,\n \nint\n \nviewType\n)\n \n{\n \n...\n \n}\n\n\n    \n@Overrides\n\n    \nboolean\n \nonFailedToRecycleView\n(\nVH\n \nholder\n,\n \nint\n \nviewType\n)\n \n{\n \n...\n \n}\n\n\n    \n// proxy to WrappedAdapter's methods\n\n    \n@Overrides\n\n    \nvoid\n \nonViewAttachedToWindow\n(\nVH\n \nholder\n)\n \n{\n\n        \nonViewAttachedToWindow\n(\nholder\n,\n \nholder\n.\ngetItemViewType\n());\n\n    \n}\n\n\n    \n@Overrides\n\n    \nvoid\n \nonViewDetachedFromWindow\n(\nVH\n \nholder\n,\n \nint\n \nviewType\n)\n \n{\n\n        \nonViewDetachedFromWindow\n(\nholder\n,\n \nholder\n.\ngetItemViewType\n());\n\n    \n}\n\n\n    \n@Overrides\n\n    \nvoid\n \nonViewRecycled\n(\nVH\n \nholder\n,\n \nint\n \nviewType\n)\n \n{\n\n        \nonViewRecycled\n(\nholder\n,\n \nholder\n.\ngetItemViewType\n());\n\n    \n}\n\n\n    \n@Overrides\n\n    \nboolean\n \nonFailedToRecycleView\n(\nVH\n \nholder\n,\n \nint\n \nviewType\n)\n \n{\n\n        \nonFailedToRecycleView\n(\nholder\n,\n \nholder\n.\ngetItemViewType\n());\n\n    \n}\n\n\n}",
            "title": "Support adapter wrapping"
        },
        {
            "location": "/wrapper-adapter/migrate-to-wrapped-adapter/#tweak-your-adapter-to-support-adapter-wrapping",
            "text": "Need to tweak several things in your adapter implemtation to  support wrapping adapter mechanism .\nBecause  WrapperAdapter  modifies  item positions ,  item IDs  and  item view types  internally.",
            "title": "Tweak your Adapter to support adapter wrapping"
        },
        {
            "location": "/wrapper-adapter/migrate-to-wrapped-adapter/#if-overriding-adaptergetitemid",
            "text": "The available range of item ID value is limited, so you cannot use full range of 64-bit integer value.  Must return a value greather than or equals to  -(2^55)  and less than or equals to  2^55 - 1 .   Note  This limitation is due to how  ItemIdComposer  packs other information into 64-bits integer value.",
            "title": "&raquo; If overriding Adapter.getItemId()"
        },
        {
            "location": "/wrapper-adapter/migrate-to-wrapped-adapter/#if-overriding-adaptergetitemviewtype",
            "text": "The available range of item view type value is limited, so you cannot use full range of 32-bit integer value.  Must return a value greather than or equals to  -(2^23)  and less than or equals to  2^23 - 1 .   Note  This limitation is due to how  ItemViewTypeComposer  packs other information into 32-bits integer value.",
            "title": "&raquo; If overriding Adapter.getItemViewType()"
        },
        {
            "location": "/wrapper-adapter/migrate-to-wrapped-adapter/#if-using-viewholdergetadaperposition-viewholdergetlayoutposition",
            "text": "Use  WrapperAdapterUtils.unwrapPosition() .  @Overfides  void   onClick ( View   v )   { \n     RecyclerView   rv   =   RecyclerViewAdapterUtils . getParentRecyclerView ( v ); \n     RecyclerView . ViewHolder   vh   =   rv . findContainingViewHolder ( v ); \n\n     int   rootPosition   =   vh . getAdapterPosition (); \n     if   ( rootPosition   ==   RecyclerView . NO_POSITION )   { \n         return ; \n     } \n\n     // need to determine adapter local position like this: \n     RecyclerView . Adapter   rootAdapter   =   rv . getAdapter (); \n     int   localPosition   =   WrapperAdapterUtils . unwrapPosition ( rootAdapter ,   this ,   rootPosition ); \n\n     Item   item   =   mItems . get ( localPosition ); \n     ...  }",
            "title": "&raquo; If using ViewHolder.getAdaperPosition() / ViewHolder.getLayoutPosition())"
        },
        {
            "location": "/wrapper-adapter/migrate-to-wrapped-adapter/#if-using-viewholdergetitemviewtype",
            "text": "Use  ItemViewTypeComposer.extractWrappedViewTypePart() .  @Overfides  void   onClick ( View   v )   { \n     RecyclerView . ViewHolder   vh   =   recyclerView . findContainingViewHolder ( v ); \n\n     int   rawViewType   =   vh . getItemViewType (); \n     int   viewType   =   ItemIdComposer . extractWrappedIdPart ( rawViewType ); \n\n     // use \"viewType\" here to determine which type of item is clicked \n     ...  }",
            "title": "&raquo; If using ViewHolder.getItemViewType()"
        },
        {
            "location": "/wrapper-adapter/migrate-to-wrapped-adapter/#if-using-viewholdergetitemid",
            "text": "Use  ItemIdComposer.extractWrappedIdPart() .  @Overfides  void   onClick ( View   v )   { \n     RecyclerView . ViewHolder   vh   =   recyclerView . findContainingViewHolder ( v ); \n\n     long   rawId   =   vh . getItemId (); \n     long   id   =   ItemIdComposer . extractWrappedIdPart ( rawId ); \n\n     // use \"id\" here to determine which item is clicked \n     ...  }",
            "title": "&raquo; If using ViewHolder.getItemId()"
        },
        {
            "location": "/wrapper-adapter/migrate-to-wrapped-adapter/#if-your-adapter-overrides-optional-methods-of-recyclerviewadapter",
            "text": "Implement the  WrappedAdapter    interface and use the  viewType  parameter instead of using  ViewHolder.getItemViewType()  This step is only required in case of the adapter overrides the following methods;   onViewAttachedToWindow()  onViewDetachedFromWindow()  onViewRecycled()  onFailedToRecycleView()   class   MyInnerAdapter < VH >   implements   WrappedAdapter < VH >   { \n     // the following four methods are provided by WrappedAdapter interface \n     @Overrides \n     void   onViewAttachedToWindow ( VH   holder ,   int   viewType )   {   ...   } \n\n     @Overrides \n     void   onViewDetachedFromWindow ( VH   holder ,   int   viewType )   {   ...   } \n\n     @Overrides \n     void   onViewRecycled ( VH   holder ,   int   viewType )   {   ...   } \n\n     @Overrides \n     boolean   onFailedToRecycleView ( VH   holder ,   int   viewType )   {   ...   } \n\n     // proxy to WrappedAdapter's methods \n     @Overrides \n     void   onViewAttachedToWindow ( VH   holder )   { \n         onViewAttachedToWindow ( holder ,   holder . getItemViewType ()); \n     } \n\n     @Overrides \n     void   onViewDetachedFromWindow ( VH   holder ,   int   viewType )   { \n         onViewDetachedFromWindow ( holder ,   holder . getItemViewType ()); \n     } \n\n     @Overrides \n     void   onViewRecycled ( VH   holder ,   int   viewType )   { \n         onViewRecycled ( holder ,   holder . getItemViewType ()); \n     } \n\n     @Overrides \n     boolean   onFailedToRecycleView ( VH   holder ,   int   viewType )   { \n         onFailedToRecycleView ( holder ,   holder . getItemViewType ()); \n     }  }",
            "title": "&raquo; If your adapter overrides optional methods of RecyclerView.Adapter"
        },
        {
            "location": "/wrapper-adapter/composed-adapter/",
            "text": "What's \nComposedAdapter\n?\n\u00b6\n\n\nThe \nComposedAdapter\n is an adapter which aggregates multiple adapters into one.\n\n\n\n\ndataSet\n \n=\n \nnew\n \nDataSet\n();\n\n\n\ncomposedAdapter\n.\naddAdapter\n(\nnew\n \nAdapterA\n(\nnew\n \nDataSet\n()));\n\n\ncomposedAdapter\n.\naddAdapter\n(\nnew\n \nAdapterB\n(\nnew\n \nDataSet\n()));\n\n\ncomposedAdapter\n.\naddAdapter\n(\nnew\n \nAdapterC\n(\nnew\n \nDataSet\n()));\n\n\n\n\n\n\n\n\n Check the \nComposedAdapter\n implementation on GitHub\n\n\n\n\n\n\nRelated methods\n\n\n\n\n \nComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter)\n\n\n \nComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter, int position)\n\n\n \nboolean ComposedAdapter.removeAdapter(ComposedChildAdapterTag tag)\n\n\n\n\n\n\nThe \nComposedAdapter\n can hold the same child adapter instance multiple times like this;\n\n\n\n\ndataSet\n \n=\n \nnew\n \nDataSet\n();\n\n\n\nadapterA\n \n=\n \nnew\n \nAdapterA\n(\ndataSet\n);\n\n\ncomposedAdapter\n.\naddAdapter\n(\nadapterA\n);\n\n\ncomposedAdapter\n.\naddAdapter\n(\nadapterA\n);\n\n\n\nadapterA2\n \n=\n \nnew\n \nAdapterA\n(\ndataSet\n);\n\n\ncomposedAdapter\n.\naddAdapter\n(\nadapterA2\n);\n\n\n\n\n\n\nItem position handling\n\u00b6\n\n\nThe \nComposedAdapter\n calls each child adapters as \nsegment\n, also child adapter's local item position are called as \noffset\n.\n\n\n\n\n\n\nRelated methods\n\n\n\n\n \nint ComposedAdapter.getSegment(ComposedChildAdapterTag tag)\n\n\n \nlong ComposedAdapter.getSegmentedPosition(int flatPosition)\n\n\n \nint ComposedAdapter.extractSegmentPart(long segmentedPosition)\n\n\n \nint ComposedAdapter.extractSegmentOffsetPart(long segmentedPosition)\n\n\n\n\n\n\nItem ID and ViewType handling\n\u00b6\n\n\nWhen merging adapters, we must take care about item IDs. They have to be unique in entire the dataset, but the problem is child datasets may contains the duplicated IDs. The \nItemIdComposer\n is used to manage this problem.\n\n\nItemIdComposer\n\u00b6\n\n\nThis utility class provides several static methods to handle the \npacked\n item ID value.\n\n\nItem IDs are expressed by 64 bits length integer in RecyclerView, so it can be embed multiple information by using bit operation technique. \nItemIdComposer\n divides 64 bits into four chunks; \nview type segment\n, \ngroup ID\n, \nchild ID\n and \nreserved bit\n.\n\n\n\n\n\n\n\n\nBits\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nbit 63\n\n\nReserved\n\n\n\n\n\n\nbit 62-56\n\n\nView type segment\n\n\n\n\n\n\nbit 55-28\n\n\nGroup ID\n\n\n\n\n\n\nbit 27-0\n\n\nChild ID\n\n\n\n\n\n\n\n\n\n\n Check the \nItemIdComposer\n implementation on GitHub\n\n\n\n\n\n\nRelated methods\n\n\n\n\n \nlong ItemIdComposer.composeSegment(int segment, long wrappedId)\n\n\n \nint ItemIdComposer.extractSegmentPart(long composedId)\n\n\n \nlong ItemIdComposer.extractExpandableGroupIdPart(long composedId)\n\n\n \nlong ItemIdComposer.extractExpandableChildIdPart(long composedId)\n\n\n \nlong ItemIdComposer.extractWrappedIdPart(long composedId)\n\n\n \nboolean ItemIdComposer.isExpandableGroup(long composedId)\n\n\n \nlong ItemIdComposer.composeExpandableGroupId(long groupId)\n\n\n \nlong ItemIdComposer.composeExpandableChildId(long groupId, long childId)\n\n\n\n\n\n\nItemViewTypeComposer\n\u00b6\n\n\nItem view type has similar problem like item ID. The \nItemViewTypeCompser\n manages packed item view type value that \nItemIdComposer\n doing it for item ID.\n\n\nItem view types are expressed by 32 bits integer in RecyclerView, and \nItemViewTypeCompser\n divides it into three chunks; \nexpandable group flag\n, \nview type segment\n and \nwrapped view type code\n.\n\n\n\n\n\n\n\n\nBits\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nbit 31\n\n\nExpandable group flag  (1: expandable group / 0: normal item)\n\n\n\n\n\n\nbit 30-24\n\n\nView type segment\n\n\n\n\n\n\nbit 27-0\n\n\nWrapped view type code\n\n\n\n\n\n\n\n\n\n\n Check the \nItemViewTypeComposer\n implementation on GitHub\n\n\n\n\n\n\nRelated methods\n\n\n\n\n \nint ItemViewTypeComposer.composeSegment(int segment, int wrappedViewType)\n\n\n \nint ItemViewTypeComposer.extractSegmentPart(int composedViewType)\n\n\n \nint ItemViewTypeComposer.extractWrappedViewTypePart(int composedViewType)\n\n\n \nboolean ItemViewTypeComposer.isExpandableGroup(int composedViewType)\n\n\n\n\n\n\nHow to migrate to \nWRAPPED\n adapter?\n\u00b6\n\n\nNeed to change several things to use your adapter wrapped with \nComposedAdapter\n. Refer to the \nTweak your Adapter to support adapter wrapping\n page for more details.",
            "title": "ComposedAdapter"
        },
        {
            "location": "/wrapper-adapter/composed-adapter/#whats-composedadapter",
            "text": "The  ComposedAdapter  is an adapter which aggregates multiple adapters into one.   dataSet   =   new   DataSet ();  composedAdapter . addAdapter ( new   AdapterA ( new   DataSet ()));  composedAdapter . addAdapter ( new   AdapterB ( new   DataSet ()));  composedAdapter . addAdapter ( new   AdapterC ( new   DataSet ()));     Check the  ComposedAdapter  implementation on GitHub    Related methods     ComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter)    ComposedChildAdapterTag ComposedAdapter.addAdapter(RecyclerView.Adapter adapter, int position)    boolean ComposedAdapter.removeAdapter(ComposedChildAdapterTag tag)    The  ComposedAdapter  can hold the same child adapter instance multiple times like this;   dataSet   =   new   DataSet ();  adapterA   =   new   AdapterA ( dataSet );  composedAdapter . addAdapter ( adapterA );  composedAdapter . addAdapter ( adapterA );  adapterA2   =   new   AdapterA ( dataSet );  composedAdapter . addAdapter ( adapterA2 );",
            "title": "What's ComposedAdapter?"
        },
        {
            "location": "/wrapper-adapter/composed-adapter/#item-position-handling",
            "text": "The  ComposedAdapter  calls each child adapters as  segment , also child adapter's local item position are called as  offset .    Related methods     int ComposedAdapter.getSegment(ComposedChildAdapterTag tag)    long ComposedAdapter.getSegmentedPosition(int flatPosition)    int ComposedAdapter.extractSegmentPart(long segmentedPosition)    int ComposedAdapter.extractSegmentOffsetPart(long segmentedPosition)",
            "title": "Item position handling"
        },
        {
            "location": "/wrapper-adapter/composed-adapter/#item-id-and-viewtype-handling",
            "text": "When merging adapters, we must take care about item IDs. They have to be unique in entire the dataset, but the problem is child datasets may contains the duplicated IDs. The  ItemIdComposer  is used to manage this problem.",
            "title": "Item ID and ViewType handling"
        },
        {
            "location": "/wrapper-adapter/composed-adapter/#itemidcomposer",
            "text": "This utility class provides several static methods to handle the  packed  item ID value.  Item IDs are expressed by 64 bits length integer in RecyclerView, so it can be embed multiple information by using bit operation technique.  ItemIdComposer  divides 64 bits into four chunks;  view type segment ,  group ID ,  child ID  and  reserved bit .     Bits  Usage      bit 63  Reserved    bit 62-56  View type segment    bit 55-28  Group ID    bit 27-0  Child ID       Check the  ItemIdComposer  implementation on GitHub    Related methods     long ItemIdComposer.composeSegment(int segment, long wrappedId)    int ItemIdComposer.extractSegmentPart(long composedId)    long ItemIdComposer.extractExpandableGroupIdPart(long composedId)    long ItemIdComposer.extractExpandableChildIdPart(long composedId)    long ItemIdComposer.extractWrappedIdPart(long composedId)    boolean ItemIdComposer.isExpandableGroup(long composedId)    long ItemIdComposer.composeExpandableGroupId(long groupId)    long ItemIdComposer.composeExpandableChildId(long groupId, long childId)",
            "title": "ItemIdComposer"
        },
        {
            "location": "/wrapper-adapter/composed-adapter/#itemviewtypecomposer",
            "text": "Item view type has similar problem like item ID. The  ItemViewTypeCompser  manages packed item view type value that  ItemIdComposer  doing it for item ID.  Item view types are expressed by 32 bits integer in RecyclerView, and  ItemViewTypeCompser  divides it into three chunks;  expandable group flag ,  view type segment  and  wrapped view type code .     Bits  Usage      bit 31  Expandable group flag  (1: expandable group / 0: normal item)    bit 30-24  View type segment    bit 27-0  Wrapped view type code       Check the  ItemViewTypeComposer  implementation on GitHub    Related methods     int ItemViewTypeComposer.composeSegment(int segment, int wrappedViewType)    int ItemViewTypeComposer.extractSegmentPart(int composedViewType)    int ItemViewTypeComposer.extractWrappedViewTypePart(int composedViewType)    boolean ItemViewTypeComposer.isExpandableGroup(int composedViewType)",
            "title": "ItemViewTypeComposer"
        },
        {
            "location": "/wrapper-adapter/composed-adapter/#how-to-migrate-to-wrapped-adapter",
            "text": "Need to change several things to use your adapter wrapped with  ComposedAdapter . Refer to the  Tweak your Adapter to support adapter wrapping  page for more details.",
            "title": "How to migrate to WRAPPED adapter?"
        },
        {
            "location": "/wrapper-adapter/headers-footers/",
            "text": "When creating headers & footers, the \nAbstractHeaderFooterWrapperAdapter\n can be a good alternative to the \nComposedAdapter\n. This class provides simple way to creating a wrapper crass for headers & footers by implementing small number of methods.\n\n\n\n\nJust looking for a sample code?\n\n\n Check the \nminimal header/footer sample code on GitHub\n.\n\n\n\n\nQuick quide\n\u00b6\n\n\nUsage\n\u00b6\n\n\nMyAdapter\n \nadapter\n \n=\n \nnew\n \nMyAdapter\n();\n\n\nMyHeadFootAdapter\n \nwrappedAdapter\n \n=\n \nnew\n \nMyHeadFootAdapter\n(\nadapter\n);\n\n\n\nrecyclerView\n.\nsetAdapter\n(\nwrappedAdapter\n);\n\n\n\n\n\n\nImplementation of headers & footers wrapper adapter\n\u00b6\n\n\nclass\n \nMyHeadFootAdapter\n \n    \nextends\n \nAbstractHeaderFooterWrapperAdapter\n<\nMyHeadFootAdapter\n.\nHeaderVH\n,\n \nMyHeadFootAdapter\n.\nFooterVH\n>\n\n\n{\n\n    \nstatic\n \nclass\n \nHeaderVH\n \nextends\n \nRecylerView\n.\nViewHolder\n \n{\n \n...\n \n}\n\n    \nstatic\n \nclass\n \nFooterVH\n \nextends\n \nRecylerView\n.\nViewHolder\n \n{\n \n...\n \n}\n\n\n    \npublic\n \nMyHeadFootAdapter\n(\nRecyclerView\n.\nAdapter\n \nadapter\n)\n \n{\n\n        \nsuper\n.\nthis\n(\nadapter\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nint\n \ngetHeaderItemCount\n()\n \n{\n\n        \nreturn\n \n<<\nNUMBER\n \nOF\n \nHEADER\n \nITEMS\n \nGOES\n \nHERE\n>>;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nint\n \ngetFooterItemCount\n()\n \n{\n\n        \nreturn\n \n<<\nNUMBER\n \nOF\n \nFOOTER\n \nITEMS\n \nGOES\n \nHERE\n>>;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nHeaderVH\n \nonCreateHeaderItemViewHolder\n(\nViewGroup\n \nparent\n,\n \nint\n \nviewType\n)\n \n{\n\n        \nView\n \nv\n \n=\n \n...;\n\n        \nreturn\n \nnew\n \nHeaderVH\n(\nv\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nFooterVH\n \nonCreateFooterItemViewHolder\n(\nViewGroup\n \nparent\n,\n \nint\n \nviewType\n)\n \n{\n\n        \nView\n \nv\n \n=\n \n...;\n\n        \nreturn\n \nnew\n \nFooterVH\n(\nv\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonBindHeaderItemViewHolder\n(\nHeaderVH\n \nholder\n,\n \nint\n \nlocalPosition\n)\n \n{\n\n        \n// bind data to header items views\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonBindFooterItemViewHolder\n(\nFooterVH\n \nholder\n,\n \nint\n \nlocalPosition\n)\n \n{\n\n        \n// bind data to footer items views\n\n    \n}\n\n\n}\n\n\n\n\n\n\nClick event handling\n\u00b6\n\n\nThe \nAbstractHeaderFooterWrapperAdapter\n extends \nComposedAdapter\n so the same click event handling approach is required.\n\n\nclass\n \nMyHeadFootAdapter\n \n    \nextends\n \nAbstractHeaderFooterWrapperAdapter\n<\nMyHeadFootAdapter\n.\nHeaderVH\n,\n \nMyHeadFootAdapter\n.\nFooterVH\n>\n\n    \nimplements\n \nView\n.\nOnClickListener\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nHeaderVH\n \nonCreateHeaderItemViewHolder\n(\nViewGroup\n \nparent\n,\n \nint\n \nviewType\n)\n \n{\n\n        \nView\n \nv\n \n=\n \n...;\n\n        \nreturn\n \nnew\n \nHeaderVH\n(\nv\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonClick\n(\nView\n \nv\n)\n \n{\n\n        \nRecyclerView\n \nrv\n \n=\n \nRecyclerViewAdapterUtils\n.\ngetParentRecyclerView\n(\nv\n);\n\n        \nRecyclerView\n.\nViewHolder\n \nvh\n \n=\n \nrv\n.\nfindContainingViewHolder\n(\nv\n);\n\n\n        \nint\n \nrootPosition\n \n=\n \nvh\n.\ngetAdapterPosition\n();\n\n        \nif\n \n(\nrootPosition\n \n==\n \nRecyclerView\n.\nNO_POSITION\n)\n \n{\n\n            \nreturn\n;\n\n        \n}\n\n\n        \n// need to determine adapter local position like this:\n\n        \nRecyclerView\n.\nAdapter\n \nrootAdapter\n \n=\n \nrv\n.\ngetAdapter\n();\n\n        \nint\n \nlocalPosition\n \n=\n \nWrapperAdapterUtils\n.\nunwrapPosition\n(\nrootAdapter\n,\n \nthis\n,\n \nrootPosition\n);\n\n\n        \n// get segment\n\n        \nlong\n \nsegmentedPosition\n \n=\n \ngetSegmentedPosition\n(\nlocalPosition\n);\n\n        \nint\n \nsegment\n \n=\n \nextractSegmentPart\n(\nsegmentedPosition\n);\n\n        \nint\n \noffset\n \n=\n \nextractSegmentOffsetPart\n(\nsegmentedPosition\n);\n\n\n        \nString\n \nmessage\n;\n\n\n        \nif\n \n(\nsegment\n \n==\n \nSEGMENT_TYPE_HEADER\n)\n \n{\n\n            \n// Header item is clicked !\n\n        \n}\n \nelse\n \nif\n \n(\nsegment\n \n==\n \nSEGMENT_TYPE_FOOTER\n)\n \n{\n\n            \n// Footer item is clicked !\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nMultipe view type handling\n\u00b6\n\n\nJust same as \nComposedAdapter\n, so need to use \nItemViewTypeComposer.extractWrappedViewTypePart()\n when using view type.\n\n\n@Override\n\n\npublic\n \nint\n \ngetHeaderItemViewType\n(\nint\n \nlocalPosition\n)\n \n{\n\n    \nreturn\n \nposition\n \n%\n \n2\n;\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nvoid\n \nonBindHeaderItemViewHolder\n(\nHeaderViewHolder\n \nholder\n,\n \nint\n \nlocalPosition\n)\n \n{\n\n    \nint\n \nviewType\n \n=\n \nItemViewTypeComposer\n.\nextractWrappedViewTypePart\n(\nholder\n.\ngetItemViewType\n());\n\n\n    \nif\n \n(\nviewType\n \n==\n \n0\n)\n \n{\n\n        \n...\n\n    \n}\n \nelse\n \n{\n\n        \n...\n\n    \n}\n\n\n}",
            "title": "Headers & Footers"
        },
        {
            "location": "/wrapper-adapter/headers-footers/#quick-quide",
            "text": "",
            "title": "Quick quide"
        },
        {
            "location": "/wrapper-adapter/headers-footers/#usage",
            "text": "MyAdapter   adapter   =   new   MyAdapter ();  MyHeadFootAdapter   wrappedAdapter   =   new   MyHeadFootAdapter ( adapter );  recyclerView . setAdapter ( wrappedAdapter );",
            "title": "Usage"
        },
        {
            "location": "/wrapper-adapter/headers-footers/#implementation-of-headers-footers-wrapper-adapter",
            "text": "class   MyHeadFootAdapter  \n     extends   AbstractHeaderFooterWrapperAdapter < MyHeadFootAdapter . HeaderVH ,   MyHeadFootAdapter . FooterVH >  { \n     static   class   HeaderVH   extends   RecylerView . ViewHolder   {   ...   } \n     static   class   FooterVH   extends   RecylerView . ViewHolder   {   ...   } \n\n     public   MyHeadFootAdapter ( RecyclerView . Adapter   adapter )   { \n         super . this ( adapter ); \n     } \n\n     @Override \n     public   int   getHeaderItemCount ()   { \n         return   << NUMBER   OF   HEADER   ITEMS   GOES   HERE >>; \n     } \n\n     @Override \n     public   int   getFooterItemCount ()   { \n         return   << NUMBER   OF   FOOTER   ITEMS   GOES   HERE >>; \n     } \n\n     @Override \n     public   HeaderVH   onCreateHeaderItemViewHolder ( ViewGroup   parent ,   int   viewType )   { \n         View   v   =   ...; \n         return   new   HeaderVH ( v ); \n     } \n\n     @Override \n     public   FooterVH   onCreateFooterItemViewHolder ( ViewGroup   parent ,   int   viewType )   { \n         View   v   =   ...; \n         return   new   FooterVH ( v ); \n     } \n\n     @Override \n     public   void   onBindHeaderItemViewHolder ( HeaderVH   holder ,   int   localPosition )   { \n         // bind data to header items views \n     } \n\n     @Override \n     public   void   onBindFooterItemViewHolder ( FooterVH   holder ,   int   localPosition )   { \n         // bind data to footer items views \n     }  }",
            "title": "Implementation of headers &amp; footers wrapper adapter"
        },
        {
            "location": "/wrapper-adapter/headers-footers/#click-event-handling",
            "text": "The  AbstractHeaderFooterWrapperAdapter  extends  ComposedAdapter  so the same click event handling approach is required.  class   MyHeadFootAdapter  \n     extends   AbstractHeaderFooterWrapperAdapter < MyHeadFootAdapter . HeaderVH ,   MyHeadFootAdapter . FooterVH > \n     implements   View . OnClickListener   { \n\n     @Override \n     public   HeaderVH   onCreateHeaderItemViewHolder ( ViewGroup   parent ,   int   viewType )   { \n         View   v   =   ...; \n         return   new   HeaderVH ( v ); \n     } \n\n     @Override \n     public   void   onClick ( View   v )   { \n         RecyclerView   rv   =   RecyclerViewAdapterUtils . getParentRecyclerView ( v ); \n         RecyclerView . ViewHolder   vh   =   rv . findContainingViewHolder ( v ); \n\n         int   rootPosition   =   vh . getAdapterPosition (); \n         if   ( rootPosition   ==   RecyclerView . NO_POSITION )   { \n             return ; \n         } \n\n         // need to determine adapter local position like this: \n         RecyclerView . Adapter   rootAdapter   =   rv . getAdapter (); \n         int   localPosition   =   WrapperAdapterUtils . unwrapPosition ( rootAdapter ,   this ,   rootPosition ); \n\n         // get segment \n         long   segmentedPosition   =   getSegmentedPosition ( localPosition ); \n         int   segment   =   extractSegmentPart ( segmentedPosition ); \n         int   offset   =   extractSegmentOffsetPart ( segmentedPosition ); \n\n         String   message ; \n\n         if   ( segment   ==   SEGMENT_TYPE_HEADER )   { \n             // Header item is clicked ! \n         }   else   if   ( segment   ==   SEGMENT_TYPE_FOOTER )   { \n             // Footer item is clicked ! \n         } \n     }  }",
            "title": "Click event handling"
        },
        {
            "location": "/wrapper-adapter/headers-footers/#multipe-view-type-handling",
            "text": "Just same as  ComposedAdapter , so need to use  ItemViewTypeComposer.extractWrappedViewTypePart()  when using view type.  @Override  public   int   getHeaderItemViewType ( int   localPosition )   { \n     return   position   %   2 ;  }  @Override  public   void   onBindHeaderItemViewHolder ( HeaderViewHolder   holder ,   int   localPosition )   { \n     int   viewType   =   ItemViewTypeComposer . extractWrappedViewTypePart ( holder . getItemViewType ()); \n\n     if   ( viewType   ==   0 )   { \n         ... \n     }   else   { \n         ... \n     }  }",
            "title": "Multipe view type handling"
        },
        {
            "location": "/wrapper-adapter/insertion-filtering/",
            "text": "Insertion\n\u00b6\n\n\nFiltering\n\u00b6",
            "title": "Insertion & Filtering"
        },
        {
            "location": "/wrapper-adapter/insertion-filtering/#insertion",
            "text": "",
            "title": "Insertion"
        },
        {
            "location": "/wrapper-adapter/insertion-filtering/#filtering",
            "text": "",
            "title": "Filtering"
        },
        {
            "location": "/draggable/",
            "text": "Just looking for a sample code?\n\n\n Check the \nminimal drag & drop sample code on GitHub\n.\n\n\n\n\nTutorial\n\u00b6\n\n\nStep 1. Make the adapter supports stable IDs\n\u00b6\n\n\n\n\nAttention\n\n\nThis step is very important. If adapter does not return stable & unique IDs, that will cause some weird behaviors (wrong animations, NPE, etc...)\n\n\n\n\nclass\n \nMyAdapter\n \nextends\n \nRecyclerView\n.\nAdapter\n<\nMyAdapter\n.\nMyViewHolder\n>\n \n{\n\n    \nMyAdapter\n()\n \n{\n\n        \nsetHasStableIds\n(\ntrue\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nlong\n \ngetItemId\n(\nint\n \nposition\n)\n \n{\n\n        \n// requires static value, it means need to keep the same value\n\n        \n// even if the item position has been changed.\n\n        \nreturn\n \nmItems\n.\nget\n(\nposition\n).\ngetId\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nStep 2. Modify layout file of item views\n\u00b6\n\n\nPut a drag handle view to the layout XML of item view.\n\n\n<!-- for itemView -->\n\n\n<FrameLayout\n\n    \nxmlns:android=\n\"http://schemas.android.com/apk/res/android\"\n\n    \nandroid:layout_width=\n\"match_parent\"\n\n    \nandroid:layout_height=\n\"56dp\"\n>\n\n    \n<!-- Content View(s) -->\n\n    \n<TextView\n\n        \nandroid:id=\n\"@android:id/text1\"\n\n        \nandroid:layout_width=\n\"match_parent\"\n\n        \nandroid:layout_height=\n\"match_parent\"\n\n        \nandroid:gravity=\n\"center\"\n/>\n\n\n</FrameLayout>\n\n\n\n\n\n\n \n \n\n\n<!-- for itemView -->\n\n\n<FrameLayout\n\n    \nxmlns:android=\n\"http://schemas.android.com/apk/res/android\"\n\n    \nandroid:layout_width=\n\"match_parent\"\n\n    \nandroid:layout_height=\n\"56dp\"\n>\n\n\n    \n<!-- Content View(s) -->\n\n    \n<TextView\n\n        \nandroid:id=\n\"@android:id/text1\"\n\n        \nandroid:layout_width=\n\"match_parent\"\n\n        \nandroid:layout_height=\n\"match_parent\"\n\n        \nandroid:gravity=\n\"center\"\n/>\n\n\n    \n<!-- Drag handle -->\n\n    \n<View\n\n        \nandroid:id=\n\"@+id/drag_handle\"\n\n        \nandroid:layout_width=\n\"32dp\"\n\n        \nandroid:layout_height=\n\"match_parent\"\n \n/>\n\n\n</FrameLayout>\n\n\n\n\n\n\nStep 3. Modify ViewHolder\n\u00b6\n\n\n\n\nChange parent class to \nAbstractDraggableItemViewHolder\n.\n\n\nImplement \ngetSwipeableContainerView()\n method\n\n\n\n\n\n\nNote\n\n\nThe \nAbstractSwipeableItemViewHolder\n class is a convenience class which implements boilerplace methods of \nDraggableItemViewHolder\n.\n\n\n\n\nclass\n \nMyAdapter\n \n...\n \n{\n\n    \nstatic\n \nclass\n \nMyViewHolder\n \nextends\n \nRecyclerView\n.\nViewHolder\n \n{\n\n        \nTextView\n \ntextView\n;\n\n        \nMyViewHolder\n(\nView\n \nv\n)\n \n{\n\n            \nsuper\n(\nv\n);\n\n            \ntextView\n \n=\n \n(\nTextView\n)\n \nv\n.\nfindViewById\n(\nandroid\n.\nR\n.\nid\n.\ntext1\n);\n\n        \n}\n\n    \n}\n\n    \n...\n\n\n}\n\n\n\n\n\n\n \n \n\n\nclass\n \nMyAdapter\n \n...\n \n{\n\n    \nstatic\n \nclass\n \nMyViewHolder\n \nextends\n \nAbstractDraggableItemViewHolder\n \n{\n\n        \nTextView\n \ntextView\n;\n\n        \nView\n \ndragHandle\n;\n\n\n        \npublic\n \nMyViewHolder\n(\nView\n \nv\n)\n \n{\n\n            \nsuper\n(\nv\n);\n\n            \ntextView\n \n=\n \n(\nTextView\n)\n \nv\n.\nfindViewById\n(\nandroid\n.\nR\n.\nid\n.\ntext1\n);\n\n            \ndragHandle\n \n=\n \nv\n.\nfindViewById\n(\nR\n.\nid\n.\ndrag_hanle\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nStep 4. Implement the \nDraggableItemAdapter\n interface\n\u00b6\n\n\nclass\n \nMyAdapter\n \nextends\n \nRecyclerView\n.\nAdapter\n<\nMyAdapter\n.\nMyViewHolder\n>\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\n \n \n\n\nclass\n \nMyAdapter\n\n        \nextends\n \nRecyclerView\n.\nAdapter\n<\nMyAdapter\n.\nMyViewHolder\n>\n\n        \nimplements\n \nDraggableItemAdapter\n<\nMyAdapter\n.\nMyViewHolder\n>\n \n{\n\n\n    \n@Override\n\n    \nboolean\n \nonCheckCanStartDrag\n(\nMyAdapter\n.\nMyViewHolder\n \nholder\n,\n \nint\n \nposition\n,\n \nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n\n        \n// see the sub-section for details\n\n    \n}\n\n\n    \n@Override\n\n    \nvoid\n \nonMoveItem\n(\nint\n \nfromPosition\n,\n \nint\n \ntoPosition\n)\n \n{\n\n        \n// see the sub-section for details\n\n    \n}\n\n\n    \n@Override\n\n    \nItemDraggableRange\n \nonGetItemDraggableRange\n(\nMyAdapter\n.\nMyViewHolder\n \nholder\n,\n \nint\n \nposition\n)\n \n{\n\n        \n// just return null for default behavior\n\n        \nreturn\n \nnull\n;\n\n    \n}\n\n\n    \n@Override\n\n    \nboolean\n \nonCheckCanDrop\n(\nint\n \ndraggingPosition\n,\n \nint\n \ndropPosition\n)\n \n{\n\n        \n// this method is not used unless calling `RecyclerViewDragDropManager.setCheckCanDropEnabled(true)` explicitly.\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\nImplement \nonCheckCanStartDrag()\n\u00b6\n\n\nThis method is invoked by the library \nwhether to check the touched finger position is inside of the \ndragHandle\n view\n.\n\n\nReturn \ntrue\n if the specified position \nx\n and \ny\n is inside of the \ndragHandle\n view. Note that the offset parameter \nx\n and \ny\n are measured from top-left of \nitemView\n.\n\n\n\n\nBasic implementation:\n\n\nboolean\n \nonCheckCanStartDrag\n(\nMyAdapter\n.\nMyViewHolder\n \nholder\n,\n \nint\n \nposition\n,\n \nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n\n    \nView\n \nitemView\n \n=\n \nholder\n.\nitemView\n;\n\n    \nView\n \ndragHandle\n \n=\n \nholder\n.\ndragHandle\n;\n\n\n    \nint\n \nhandleWidth\n \n=\n \ndragHandle\n.\ngetWidth\n();\n\n    \nint\n \nhandleHeight\n \n=\n \ndragHandle\n.\ngetHeight\n();\n\n    \nint\n \nhandleLeft\n \n=\n \ndragHandle\n.\ngetLeft\n();\n\n    \nint\n \nhandleTop\n \n=\n \ndragHnadle\n.\ngetTop\n();\n\n\n    \nreturn\n \n(\nx\n \n>=\n \nhandleLeft\n)\n \n&&\n \n(\nx\n \n<\n \nhandleLeft\n \n+\n \nhandleWidth\n)\n \n&&\n\n           \n(\ny\n \n>=\n \nhandleTop\n)\n \n&&\n \n(\ny\n \n<\n \nhandleTop\n \n+\n \nhandleHeight\n);\n\n\n}\n\n\n\n\n\n\nImplement \nonMoveItem()\n\u00b6\n\n\nThis method is invoked by the library when finished dragging. Basic implemtation will be like the follwing;\n\n\nList\n<\nMyItem\n>\n \nitems\n;\n\n\n\n@Override\n\n\nvoid\n \nonMoveItem\n(\nint\n \nfromPosition\n,\n \nint\n \ntoPosition\n)\n \n{\n\n    \nMyItem\n \nremoved\n \n=\n \nitems\n.\nremove\n(\nfromPosition\n);\n\n    \nitems\n.\nadd\n(\ntoPosition\n,\n \nremoved\n);\n\n\n    \nnotifyItemMoved\n(\nfromPosition\n,\n \ntoPosition\n);\n\n\n}\n\n\n\n\n\n\nStep 5. Modify initialization process of RecyclerView\n\u00b6\n\n\nPut some additional initialization process in your Activity / Fragment.\n\n\n\n\nInstantiate \nRecyclerViewDragManager\n\n\nCreate a wrapped adapter and set it to \nRecyclerView\n\n\nAttach \nRecyclerView\n to \nRecyclerViewDragManager\n\n\n\n\nvoid\n \nonCreate\n()\n \n{\n\n    \n...\n\n\n    \nRecyclerView\n \nrecyclerView\n \n=\n \nfindViewById\n(\nR\n.\nid\n.\nrecyclerView\n);\n\n    \nMyAdapter\n \nadapter\n \n=\n \nnew\n \nMyAdapter\n();\n\n\n    \nrecyclerView\n.\nsetAdapter\n(\nadapter\n);\n\n    \nrecyclerView\n.\nsetLayoutManager\n(\nnew\n \nLinearLayoutManager\n(\nthis\n));\n\n\n}\n\n\n\n\n\n\n \n \n\n\nvoid\n \nonCreate\n()\n \n{\n\n    \n...\n\n\n    \nRecyclerView\n \nrecyclerView\n \n=\n \nfindViewById\n(\nR\n.\nid\n.\nrecyclerView\n);\n\n    \nRecyclerViewDragManager\n \ndragDropManager\n \n=\n \nnew\n \nRecyclerViewDragManager\n();\n\n\n    \nMyAdapter\n \nadapter\n \n=\n \nnew\n \nMyAdapter\n();\n\n    \nRecyclerView\n.\nAdapter\n \nwrappedAdapter\n \n=\n \ndragDropManager\n.\ncreateWrappedAdapter\n(\nadapter\n);\n\n\n    \nrecyclerView\n.\nsetAdapter\n(\nwrappedAdapter\n);\n\n    \nrecyclerView\n.\nsetLayoutManager\n(\nnew\n \nLinearLayoutManager\n(\nthis\n));\n\n\n    \n// disable change animations\n\n    \n((\nSimpleItemAnimator\n)\n \nmRecyclerView\n.\ngetItemAnimator\n()).\nsetSupportsChangeAnimations\n(\nfalse\n);\n\n\n    \n// [OPTIONAL]\n\n    \n// dragDropManager.setInitiateOnTouch(true);\n\n    \n// dragDropManager.setInitiateOnLongPress(true);\n\n    \n// dragDropManager.setInitiateOnMove(true);\n\n\n    \ndragDropManager\n.\nattachRecyclerView\n(\nrecyclerView\n);\n\n\n}\n\n\n\n\n\n\nStep 6. Custom more and details of the implementation\n\u00b6\n\n\nPlease refer to \nthe demo app implementation \n for more details.",
            "title": "Drag & Drop"
        },
        {
            "location": "/draggable/#tutorial",
            "text": "",
            "title": "Tutorial"
        },
        {
            "location": "/draggable/#step-1-make-the-adapter-supports-stable-ids",
            "text": "Attention  This step is very important. If adapter does not return stable & unique IDs, that will cause some weird behaviors (wrong animations, NPE, etc...)   class   MyAdapter   extends   RecyclerView . Adapter < MyAdapter . MyViewHolder >   { \n     MyAdapter ()   { \n         setHasStableIds ( true ); \n     } \n\n     @Override \n     public   long   getItemId ( int   position )   { \n         // requires static value, it means need to keep the same value \n         // even if the item position has been changed. \n         return   mItems . get ( position ). getId (); \n     }  }",
            "title": "Step 1. Make the adapter supports stable IDs"
        },
        {
            "location": "/draggable/#step-2-modify-layout-file-of-item-views",
            "text": "Put a drag handle view to the layout XML of item view.  <!-- for itemView -->  <FrameLayout \n     xmlns:android= \"http://schemas.android.com/apk/res/android\" \n     android:layout_width= \"match_parent\" \n     android:layout_height= \"56dp\" > \n     <!-- Content View(s) --> \n     <TextView \n         android:id= \"@android:id/text1\" \n         android:layout_width= \"match_parent\" \n         android:layout_height= \"match_parent\" \n         android:gravity= \"center\" />  </FrameLayout>        <!-- for itemView -->  <FrameLayout \n     xmlns:android= \"http://schemas.android.com/apk/res/android\" \n     android:layout_width= \"match_parent\" \n     android:layout_height= \"56dp\" > \n\n     <!-- Content View(s) --> \n     <TextView \n         android:id= \"@android:id/text1\" \n         android:layout_width= \"match_parent\" \n         android:layout_height= \"match_parent\" \n         android:gravity= \"center\" /> \n\n     <!-- Drag handle --> \n     <View \n         android:id= \"@+id/drag_handle\" \n         android:layout_width= \"32dp\" \n         android:layout_height= \"match_parent\"   />  </FrameLayout>",
            "title": "Step 2. Modify layout file of item views"
        },
        {
            "location": "/draggable/#step-3-modify-viewholder",
            "text": "Change parent class to  AbstractDraggableItemViewHolder .  Implement  getSwipeableContainerView()  method    Note  The  AbstractSwipeableItemViewHolder  class is a convenience class which implements boilerplace methods of  DraggableItemViewHolder .   class   MyAdapter   ...   { \n     static   class   MyViewHolder   extends   RecyclerView . ViewHolder   { \n         TextView   textView ; \n         MyViewHolder ( View   v )   { \n             super ( v ); \n             textView   =   ( TextView )   v . findViewById ( android . R . id . text1 ); \n         } \n     } \n     ...  }        class   MyAdapter   ...   { \n     static   class   MyViewHolder   extends   AbstractDraggableItemViewHolder   { \n         TextView   textView ; \n         View   dragHandle ; \n\n         public   MyViewHolder ( View   v )   { \n             super ( v ); \n             textView   =   ( TextView )   v . findViewById ( android . R . id . text1 ); \n             dragHandle   =   v . findViewById ( R . id . drag_hanle ); \n         } \n     }  }",
            "title": "Step 3. Modify ViewHolder"
        },
        {
            "location": "/draggable/#step-4-implement-the-draggableitemadapter-interface",
            "text": "class   MyAdapter   extends   RecyclerView . Adapter < MyAdapter . MyViewHolder >   { \n     ...  }        class   MyAdapter \n         extends   RecyclerView . Adapter < MyAdapter . MyViewHolder > \n         implements   DraggableItemAdapter < MyAdapter . MyViewHolder >   { \n\n     @Override \n     boolean   onCheckCanStartDrag ( MyAdapter . MyViewHolder   holder ,   int   position ,   int   x ,   int   y )   { \n         // see the sub-section for details \n     } \n\n     @Override \n     void   onMoveItem ( int   fromPosition ,   int   toPosition )   { \n         // see the sub-section for details \n     } \n\n     @Override \n     ItemDraggableRange   onGetItemDraggableRange ( MyAdapter . MyViewHolder   holder ,   int   position )   { \n         // just return null for default behavior \n         return   null ; \n     } \n\n     @Override \n     boolean   onCheckCanDrop ( int   draggingPosition ,   int   dropPosition )   { \n         // this method is not used unless calling `RecyclerViewDragDropManager.setCheckCanDropEnabled(true)` explicitly. \n         return   true ; \n     }  }",
            "title": "Step 4. Implement the DraggableItemAdapter interface"
        },
        {
            "location": "/draggable/#implement-oncheckcanstartdrag",
            "text": "This method is invoked by the library  whether to check the touched finger position is inside of the  dragHandle  view .  Return  true  if the specified position  x  and  y  is inside of the  dragHandle  view. Note that the offset parameter  x  and  y  are measured from top-left of  itemView .   Basic implementation:  boolean   onCheckCanStartDrag ( MyAdapter . MyViewHolder   holder ,   int   position ,   int   x ,   int   y )   { \n     View   itemView   =   holder . itemView ; \n     View   dragHandle   =   holder . dragHandle ; \n\n     int   handleWidth   =   dragHandle . getWidth (); \n     int   handleHeight   =   dragHandle . getHeight (); \n     int   handleLeft   =   dragHandle . getLeft (); \n     int   handleTop   =   dragHnadle . getTop (); \n\n     return   ( x   >=   handleLeft )   &&   ( x   <   handleLeft   +   handleWidth )   && \n            ( y   >=   handleTop )   &&   ( y   <   handleTop   +   handleHeight );  }",
            "title": "Implement onCheckCanStartDrag()"
        },
        {
            "location": "/draggable/#implement-onmoveitem",
            "text": "This method is invoked by the library when finished dragging. Basic implemtation will be like the follwing;  List < MyItem >   items ;  @Override  void   onMoveItem ( int   fromPosition ,   int   toPosition )   { \n     MyItem   removed   =   items . remove ( fromPosition ); \n     items . add ( toPosition ,   removed ); \n\n     notifyItemMoved ( fromPosition ,   toPosition );  }",
            "title": "Implement onMoveItem()"
        },
        {
            "location": "/draggable/#step-5-modify-initialization-process-of-recyclerview",
            "text": "Put some additional initialization process in your Activity / Fragment.   Instantiate  RecyclerViewDragManager  Create a wrapped adapter and set it to  RecyclerView  Attach  RecyclerView  to  RecyclerViewDragManager   void   onCreate ()   { \n     ... \n\n     RecyclerView   recyclerView   =   findViewById ( R . id . recyclerView ); \n     MyAdapter   adapter   =   new   MyAdapter (); \n\n     recyclerView . setAdapter ( adapter ); \n     recyclerView . setLayoutManager ( new   LinearLayoutManager ( this ));  }        void   onCreate ()   { \n     ... \n\n     RecyclerView   recyclerView   =   findViewById ( R . id . recyclerView ); \n     RecyclerViewDragManager   dragDropManager   =   new   RecyclerViewDragManager (); \n\n     MyAdapter   adapter   =   new   MyAdapter (); \n     RecyclerView . Adapter   wrappedAdapter   =   dragDropManager . createWrappedAdapter ( adapter ); \n\n     recyclerView . setAdapter ( wrappedAdapter ); \n     recyclerView . setLayoutManager ( new   LinearLayoutManager ( this )); \n\n     // disable change animations \n     (( SimpleItemAnimator )   mRecyclerView . getItemAnimator ()). setSupportsChangeAnimations ( false ); \n\n     // [OPTIONAL] \n     // dragDropManager.setInitiateOnTouch(true); \n     // dragDropManager.setInitiateOnLongPress(true); \n     // dragDropManager.setInitiateOnMove(true); \n\n     dragDropManager . attachRecyclerView ( recyclerView );  }",
            "title": "Step 5. Modify initialization process of RecyclerView"
        },
        {
            "location": "/draggable/#step-6-custom-more-and-details-of-the-implementation",
            "text": "Please refer to  the demo app implementation   for more details.",
            "title": "Step 6. Custom more and details of the implementation"
        },
        {
            "location": "/swipeable/",
            "text": "Just looking for a sample code?\n\n\n Check the \nminimal drag & drop sample code on GitHub\n.\n\n\n\n\nTutorial\n\u00b6\n\n\nStep 1. Make the adapter supports stable IDs\n\u00b6\n\n\n\n\nAttention\n\n\nThis step is very important. If adapter does not return stable & unique IDs, that will cause some weird behaviors (wrong animations, NPE, etc...)\n\n\n\n\nclass\n \nMyAdapter\n \nextends\n \nRecyclerView\n.\nAdapter\n<\nMyAdapter\n.\nMyViewHolder\n>\n \n{\n\n    \nMyAdapter\n()\n \n{\n\n        \nsetHasStableIds\n(\ntrue\n);\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nlong\n \ngetItemId\n(\nint\n \nposition\n)\n \n{\n\n        \n// requires static value, it means need to keep the same value\n\n        \n// even if the item position has been changed.\n\n        \nreturn\n \nmItems\n.\nget\n(\nposition\n).\ngetId\n();\n\n    \n}\n\n\n}\n\n\n\n\n\n\nStep 2. Modify layout file of item views\n\u00b6\n\n\nWrap content views with another \nFrameLayout\n whitch has \n@+id/container\n ID.\n\n\n<!-- for itemView -->\n\n\n<FrameLayout\n\n    \nxmlns:android=\n\"http://schemas.android.com/apk/res/android\"\n\n    \nandroid:layout_width=\n\"match_parent\"\n\n    \nandroid:layout_height=\n\"56dp\"\n>\n\n    \n<!-- Content View(s) -->\n\n    \n<TextView\n\n        \nandroid:id=\n\"@android:id/text1\"\n\n        \nandroid:layout_width=\n\"match_parent\"\n\n        \nandroid:layout_height=\n\"match_parent\"\n\n        \nandroid:gravity=\n\"center\"\n/>\n\n\n</FrameLayout>\n\n\n\n\n\n\n<!-- for itemView -->\n\n\n<FrameLayout\n\n    \nxmlns:android=\n\"http://schemas.android.com/apk/res/android\"\n\n    \nandroid:layout_width=\n\"match_parent\"\n\n    \nandroid:layout_height=\n\"56dp\"\n>\n\n\n    \n<!-- for getSwipeableContainerView() -->\n\n    \n<FrameLayout\n\n        \nandroid:id=\n\"@+id/container\"\n\n        \nandroid:layout_width=\n\"match_parent\"\n\n        \nandroid:layout_height=\n\"match_parent\"\n>\n\n\n        \n<!-- Content View(s) -->\n\n        \n<TextView\n\n            \nandroid:id=\n\"@android:id/text1\"\n\n            \nandroid:layout_width=\n\"match_parent\"\n\n            \nandroid:layout_height=\n\"match_parent\"\n\n            \nandroid:gravity=\n\"center\"\n/>\n\n\n    \n</FrameLayout>\n\n\n</FrameLayout>\n\n\n\n\n\n\nStep 3. Modify ViewHolder\n\u00b6\n\n\n\n\nChange parent class to \nAbstractSwipeableItemViewHolder\n.\n\n\nImplement \ngetSwipeableContainerView()\n method\n\n\n\n\n\n\nNote\n\n\nThe \nAbstractSwipeableItemViewHolder\n class is a convenience class which implements boilerplace methods of \nSwipeableItemViewHolder\n.\n\n\n\n\nclass\n \nMyAdapter\n \n...\n \n{\n\n    \nstatic\n \nclass\n \nMyViewHolder\n \nextends\n \nRecyclerView\n.\nViewHolder\n \n{\n\n        \nTextView\n \ntextView\n;\n\n        \nMyViewHolder\n(\nView\n \nv\n)\n \n{\n\n            \nsuper\n(\nv\n);\n\n            \ntextView\n \n=\n \n(\nTextView\n)\n \nv\n.\nfindViewById\n(\nandroid\n.\nR\n.\nid\n.\ntext1\n);\n\n        \n}\n\n    \n}\n\n    \n...\n\n\n}\n\n\n\n\n\n\nclass\n \nMyAdapter\n \n...\n \n{\n\n    \nstatic\n \nclass\n \nMyViewHolder\n \nextends\n \nAbstractSwipeableItemViewHolder\n \n{\n\n        \nTextView\n \ntextView\n;\n\n        \nFrameLayout\n \ncontainerView\n;\n\n\n        \npublic\n \nMyViewHolder\n(\nView\n \nv\n)\n \n{\n\n            \nsuper\n(\nv\n);\n\n            \ntextView\n \n=\n \n(\nTextView\n)\n \nv\n.\nfindViewById\n(\nandroid\n.\nR\n.\nid\n.\ntext1\n);\n\n            \ncontainerView\n \n=\n \n(\nFrameLayout\n)\n \nv\n.\nfindViewById\n(\nR\n.\nid\n.\ncontainer\n);\n\n        \n}\n\n\n        \n@Override\n\n        \npublic\n \nView\n \ngetSwipeableContainerView\n()\n \n{\n\n            \nreturn\n \ncontainerView\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nStep 4. Implement the \nSwipeableItemAdapter\n interface\n\u00b6\n\n\nclass\n \nMyAdapter\n \nextends\n \nRecyclerView\n.\nAdapter\n<\nMyAdapter\n.\nMyViewHolder\n>\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\nclass\n \nMyAdapter\n\n        \nextends\n \nRecyclerView\n.\nAdapter\n<\nMyAdapter\n.\nMyViewHolder\n>\n\n        \nimplements\n \nSwipeableItemAdapter\n<\nMyAdapter\n.\nMyViewHolder\n>\n \n{\n\n\n    \n@Override\n\n    \npublic\n \nint\n \nonGetSwipeReactionType\n(\nMyViewHolder\n \nholder\n,\n \nint\n \nposition\n,\n \nint\n \nx\n,\n \nint\n \ny\n)\n \n{\n\n        \n// Make swipeable to LEFT direction\n\n        \nreturn\n \nSwipeable\n.\nREACTION_CAN_SWIPE_LEFT\n;\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonSetSwipeBackground\n(\nMyViewHolder\n \nholder\n,\n \nint\n \nposition\n,\n \nint\n \ntype\n)\n \n{\n\n        \n// You can set background color/resource to holder.itemView.\n\n\n        \n// The argument \"type\" can be one of the followings;\n\n        \n// - Swipeable.DRAWABLE_SWIPE_NEUTRAL_BACKGROUND\n\n        \n// - Swipeable.DRAWABLE_SWIPE_LEFT_BACKGROUND\n\n        \n// (- Swipeable.DRAWABLE_SWIPE_UP_BACKGROUND)\n\n        \n// (- Swipeable.DRAWABLE_SWIPE_RIGHT_BACKGROUND)\n\n        \n// (- Swipeable.DRAWABLE_SWIPE_DOWN_BACKGROUND)\n\n\n        \nif\n \n(\ntype\n \n==\n \nSwipeable\n.\nDRAWABLE_SWIPE_LEFT_BACKGROUND\n)\n \n{\n\n            \nholder\n.\nitemView\n.\nsetBackgroundColor\n(\nColor\n.\nYELLOW\n);\n\n        \n}\n \nelse\n \n{\n\n            \nholder\n.\nitemView\n.\nsetBackgroundColor\n(\nColor\n.\nTRANSPARENT\n);\n\n        \n}\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nSwipeResultAction\n \nonSwipeItem\n(\nMyViewHolder\n \nholder\n,\n \nint\n \nposition\n,\n \nint\n \nresult\n)\n \n{\n\n        \n// Return sub class of the SwipeResultAction.\n\n        \n//\n\n        \n// Available base (abstract) classes are;\n\n        \n// - SwipeResultActionDefault\n\n        \n// - SwipeResultActionMoveToSwipedDirection\n\n        \n// - SwipeResultActionRemoveItem\n\n        \n// - SwipeResultActionDoNothing\n\n\n        \n// The argument \"result\" can be one of the followings;\n\n        \n// \n\n        \n// - Swipeable.RESULT_CANCELED\n\n        \n// - Swipeable.RESULT_SWIPED_LEFT\n\n        \n// (- Swipeable.RESULT_SWIPED_UP)\n\n        \n// (- Swipeable.RESULT_SWIPED_RIGHT)\n\n        \n// (- Swipeable.RESULT_SWIPED_DOWN)\n\n\n        \nif\n \n(\nresult\n \n==\n \nSwipeable\n.\nRESULT_LEFT\n)\n \n{\n\n            \nreturn\n \nnew\n \nSwipeResultActionMoveToSwipedDirection\n()\n \n{\n\n                \n// Optionally, you can override these three methods\n\n                \n// - void onPerformAction()\n\n                \n// - void onSlideAnimationEnd()\n\n                \n// - void onCleanUp()\n\n            \n};\n\n        \n}\n \nelse\n \n{\n\n            \nreturn\n \nnew\n \nSwipeResultActionDoNothing\n();\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nStep 5. Modify initialization process of RecyclerView\n\u00b6\n\n\nPut some additional initialization process in your Activity / Fragment.\n\n\n\n\nInstantiate \nRecyclerViewSwipeManager\n\n\nCreate a wrapped adapter and set it to \nRecyclerView\n\n\nAttach \nRecyclerView\n to \nRecyclerViewSwipeManager\n\n\n\n\nvoid\n \nonCreate\n()\n \n{\n\n    \n...\n\n\n    \nRecyclerView\n \nrecyclerView\n \n=\n \nfindViewById\n(\nR\n.\nid\n.\nrecyclerView\n);\n\n    \nMyAdapter\n \nadapter\n \n=\n \nnew\n \nMyAdapter\n();\n\n\n    \nrecyclerView\n.\nsetAdapter\n(\nadapter\n);\n\n    \nrecyclerView\n.\nsetLayoutManager\n(\nnew\n \nLinearLayoutManager\n(\nthis\n));\n\n\n}\n\n\n\n\n\n\n \n \n\n\nvoid\n \nonCreate\n()\n \n{\n\n    \n...\n\n\n    \nRecyclerView\n \nrecyclerView\n \n=\n \nfindViewById\n(\nR\n.\nid\n.\nrecyclerView\n);\n\n    \nRecyclerViewSwipeManager\n \nswipeManager\n \n=\n \nnew\n \nRecyclerViewSwipeManager\n();\n\n\n    \nMyAdapter\n \nadapter\n \n=\n \nnew\n \nMyAdapter\n();\n\n    \nRecyclerView\n.\nAdapter\n \nwrappedAdapter\n \n=\n \nswipeManager\n.\ncreateWrappedAdapter\n(\nadapter\n);\n\n\n    \nrecyclerView\n.\nsetAdapter\n(\nwrappedAdapter\n);\n\n    \nrecyclerView\n.\nsetLayoutManager\n(\nnew\n \nLinearLayoutManager\n(\nthis\n));\n\n\n    \n// disable change animations\n\n    \n((\nSimpleItemAnimator\n)\n \nmRecyclerView\n.\ngetItemAnimator\n()).\nsetSupportsChangeAnimations\n(\nfalse\n);\n\n\n    \nswipeManager\n.\nattachRecyclerView\n(\nrecyclerView\n);\n\n\n}\n\n\n\n\n\n\nStep 6. Custom more and details of the implementation\n\u00b6\n\n\nPlease refer to \nthe demo app implementation \n for more details.",
            "title": "Swipeable"
        },
        {
            "location": "/swipeable/#tutorial",
            "text": "",
            "title": "Tutorial"
        },
        {
            "location": "/swipeable/#step-1-make-the-adapter-supports-stable-ids",
            "text": "Attention  This step is very important. If adapter does not return stable & unique IDs, that will cause some weird behaviors (wrong animations, NPE, etc...)   class   MyAdapter   extends   RecyclerView . Adapter < MyAdapter . MyViewHolder >   { \n     MyAdapter ()   { \n         setHasStableIds ( true ); \n     } \n\n     @Override \n     public   long   getItemId ( int   position )   { \n         // requires static value, it means need to keep the same value \n         // even if the item position has been changed. \n         return   mItems . get ( position ). getId (); \n     }  }",
            "title": "Step 1. Make the adapter supports stable IDs"
        },
        {
            "location": "/swipeable/#step-2-modify-layout-file-of-item-views",
            "text": "Wrap content views with another  FrameLayout  whitch has  @+id/container  ID.  <!-- for itemView -->  <FrameLayout \n     xmlns:android= \"http://schemas.android.com/apk/res/android\" \n     android:layout_width= \"match_parent\" \n     android:layout_height= \"56dp\" > \n     <!-- Content View(s) --> \n     <TextView \n         android:id= \"@android:id/text1\" \n         android:layout_width= \"match_parent\" \n         android:layout_height= \"match_parent\" \n         android:gravity= \"center\" />  </FrameLayout>   <!-- for itemView -->  <FrameLayout \n     xmlns:android= \"http://schemas.android.com/apk/res/android\" \n     android:layout_width= \"match_parent\" \n     android:layout_height= \"56dp\" > \n\n     <!-- for getSwipeableContainerView() --> \n     <FrameLayout \n         android:id= \"@+id/container\" \n         android:layout_width= \"match_parent\" \n         android:layout_height= \"match_parent\" > \n\n         <!-- Content View(s) --> \n         <TextView \n             android:id= \"@android:id/text1\" \n             android:layout_width= \"match_parent\" \n             android:layout_height= \"match_parent\" \n             android:gravity= \"center\" /> \n\n     </FrameLayout>  </FrameLayout>",
            "title": "Step 2. Modify layout file of item views"
        },
        {
            "location": "/swipeable/#step-3-modify-viewholder",
            "text": "Change parent class to  AbstractSwipeableItemViewHolder .  Implement  getSwipeableContainerView()  method    Note  The  AbstractSwipeableItemViewHolder  class is a convenience class which implements boilerplace methods of  SwipeableItemViewHolder .   class   MyAdapter   ...   { \n     static   class   MyViewHolder   extends   RecyclerView . ViewHolder   { \n         TextView   textView ; \n         MyViewHolder ( View   v )   { \n             super ( v ); \n             textView   =   ( TextView )   v . findViewById ( android . R . id . text1 ); \n         } \n     } \n     ...  }   class   MyAdapter   ...   { \n     static   class   MyViewHolder   extends   AbstractSwipeableItemViewHolder   { \n         TextView   textView ; \n         FrameLayout   containerView ; \n\n         public   MyViewHolder ( View   v )   { \n             super ( v ); \n             textView   =   ( TextView )   v . findViewById ( android . R . id . text1 ); \n             containerView   =   ( FrameLayout )   v . findViewById ( R . id . container ); \n         } \n\n         @Override \n         public   View   getSwipeableContainerView ()   { \n             return   containerView ; \n         } \n     }  }",
            "title": "Step 3. Modify ViewHolder"
        },
        {
            "location": "/swipeable/#step-4-implement-the-swipeableitemadapter-interface",
            "text": "class   MyAdapter   extends   RecyclerView . Adapter < MyAdapter . MyViewHolder >   { \n     ...  }   class   MyAdapter \n         extends   RecyclerView . Adapter < MyAdapter . MyViewHolder > \n         implements   SwipeableItemAdapter < MyAdapter . MyViewHolder >   { \n\n     @Override \n     public   int   onGetSwipeReactionType ( MyViewHolder   holder ,   int   position ,   int   x ,   int   y )   { \n         // Make swipeable to LEFT direction \n         return   Swipeable . REACTION_CAN_SWIPE_LEFT ; \n     } \n\n     @Override \n     public   void   onSetSwipeBackground ( MyViewHolder   holder ,   int   position ,   int   type )   { \n         // You can set background color/resource to holder.itemView. \n\n         // The argument \"type\" can be one of the followings; \n         // - Swipeable.DRAWABLE_SWIPE_NEUTRAL_BACKGROUND \n         // - Swipeable.DRAWABLE_SWIPE_LEFT_BACKGROUND \n         // (- Swipeable.DRAWABLE_SWIPE_UP_BACKGROUND) \n         // (- Swipeable.DRAWABLE_SWIPE_RIGHT_BACKGROUND) \n         // (- Swipeable.DRAWABLE_SWIPE_DOWN_BACKGROUND) \n\n         if   ( type   ==   Swipeable . DRAWABLE_SWIPE_LEFT_BACKGROUND )   { \n             holder . itemView . setBackgroundColor ( Color . YELLOW ); \n         }   else   { \n             holder . itemView . setBackgroundColor ( Color . TRANSPARENT ); \n         } \n     } \n\n     @Override \n     public   SwipeResultAction   onSwipeItem ( MyViewHolder   holder ,   int   position ,   int   result )   { \n         // Return sub class of the SwipeResultAction. \n         // \n         // Available base (abstract) classes are; \n         // - SwipeResultActionDefault \n         // - SwipeResultActionMoveToSwipedDirection \n         // - SwipeResultActionRemoveItem \n         // - SwipeResultActionDoNothing \n\n         // The argument \"result\" can be one of the followings; \n         //  \n         // - Swipeable.RESULT_CANCELED \n         // - Swipeable.RESULT_SWIPED_LEFT \n         // (- Swipeable.RESULT_SWIPED_UP) \n         // (- Swipeable.RESULT_SWIPED_RIGHT) \n         // (- Swipeable.RESULT_SWIPED_DOWN) \n\n         if   ( result   ==   Swipeable . RESULT_LEFT )   { \n             return   new   SwipeResultActionMoveToSwipedDirection ()   { \n                 // Optionally, you can override these three methods \n                 // - void onPerformAction() \n                 // - void onSlideAnimationEnd() \n                 // - void onCleanUp() \n             }; \n         }   else   { \n             return   new   SwipeResultActionDoNothing (); \n         } \n     }  }",
            "title": "Step 4. Implement the SwipeableItemAdapter interface"
        },
        {
            "location": "/swipeable/#step-5-modify-initialization-process-of-recyclerview",
            "text": "Put some additional initialization process in your Activity / Fragment.   Instantiate  RecyclerViewSwipeManager  Create a wrapped adapter and set it to  RecyclerView  Attach  RecyclerView  to  RecyclerViewSwipeManager   void   onCreate ()   { \n     ... \n\n     RecyclerView   recyclerView   =   findViewById ( R . id . recyclerView ); \n     MyAdapter   adapter   =   new   MyAdapter (); \n\n     recyclerView . setAdapter ( adapter ); \n     recyclerView . setLayoutManager ( new   LinearLayoutManager ( this ));  }        void   onCreate ()   { \n     ... \n\n     RecyclerView   recyclerView   =   findViewById ( R . id . recyclerView ); \n     RecyclerViewSwipeManager   swipeManager   =   new   RecyclerViewSwipeManager (); \n\n     MyAdapter   adapter   =   new   MyAdapter (); \n     RecyclerView . Adapter   wrappedAdapter   =   swipeManager . createWrappedAdapter ( adapter ); \n\n     recyclerView . setAdapter ( wrappedAdapter ); \n     recyclerView . setLayoutManager ( new   LinearLayoutManager ( this )); \n\n     // disable change animations \n     (( SimpleItemAnimator )   mRecyclerView . getItemAnimator ()). setSupportsChangeAnimations ( false ); \n\n     swipeManager . attachRecyclerView ( recyclerView );  }",
            "title": "Step 5. Modify initialization process of RecyclerView"
        },
        {
            "location": "/swipeable/#step-6-custom-more-and-details-of-the-implementation",
            "text": "Please refer to  the demo app implementation   for more details.",
            "title": "Step 6. Custom more and details of the implementation"
        },
        {
            "location": "/expandable/",
            "text": "Just looking for a sample code?\n\n\n Check the \nminimal expand & collapse sample code on GitHub\n.\n\n\n\n\nTutorial\n\u00b6\n\n\nStep 1. Extend \nAbstractExpandableItemAdapter\n instead of \nRecyclerView.Adapter\n\u00b6\n\n\nFirst, you need to extend \nAbstractExpandableItemAdapter\n to use expandable items feature. This class implements \nRecyclerView.Adapter\n's methods and some of them are sealed via \nfinal\n keyword. Instead, it provides some \nGroup\n / \nChild\n prefixed version of `RecyclerView.Adapter' methods.\n\n\nclass\n \nMyChildItem\n \n{\n\n    \npublic\n \nlong\n \nid\n;\n\n\n}\n\n\n\nclass\n \nMyGroupItem\n \n{\n\n    \npublic\n \nlong\n \nid\n;\n\n    \nList\n<\nMyChildItem\n>\n \nchildren\n;\n\n\n}\n\n\n\nclass\n \nMyAdapter\n \nextends\n \nAbstractExpandableItemAdapter\n<\nMyAdapter\n.\nMyGroupVH\n,\n \nMyAdapter\n.\nMyChildVH\n>\n \n{\n\n    \nList\n<\nMyGroupItem\n>\n \nitems\n;\n\n\n    \npublic\n \nMyAdapter\n()\n \n{\n\n        \nsetHasStableIds\n(\ntrue\n);\n \n// this is required for expandable feature.\n\n    \n}\n\n\n    \n@Override\n\n    \npublic\n \nint\n \ngetGroupCount\n()\n \n{\n \n...\n \n}\n\n\n    \n@Override\n\n    \npublic\n \nint\n \ngetChildCount\n(\nint\n \ngroupPosition\n)\n \n{\n \n...\n \n}\n\n\n    \n@Override\n\n    \npublic\n \nlong\n \ngetGroupId\n(\nint\n \ngroupPosition\n)\n \n{\n \n...\n \n}\n\n\n    \n@Override\n\n    \npublic\n \nlong\n \ngetChildId\n(\nint\n \ngroupPosition\n,\n \nint\n \nchildPosition\n)\n \n{\n \n...\n \n}\n\n\n    \n@Override\n\n    \npublic\n \nMyGroupVH\n \nonCreateGroupViewHolder\n(\nViewGroup\n \nparent\n,\n \nint\n \nviewType\n)\n \n{\n \n...\n \n}\n\n\n    \n@Override\n\n    \npublic\n \nMyChildViewHolder\n \nonCreateChildViewHolder\n(\nViewGroup\n \nparent\n,\n \nint\n \nviewType\n)\n \n{\n \n...\n \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonBindGroupViewHolder\n(\nMyGroupVH\n \nholder\n,\n \nint\n \ngroupPosition\n,\n \nint\n \nviewType\n)\n \n{\n \n...\n \n}\n\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nonBindChildViewHolder\n(\nMyChildViewHolder\n \nholder\n,\n \nint\n \ngroupPosition\n,\n \nint\n \nchildPosition\n,\n \nint\n \nviewType\n)\n \n{\n \n...\n \n}\n\n\n    \n@Override\n\n    \npublic\n \nboolean\n \nonCheckCanExpandOrCollapseGroup\n(\nMyGroupVH\n \nholder\n,\n \nint\n \ngroupPosition\n,\n \nint\n \nx\n,\n \nint\n \ny\n,\n \nboolean\n \nexpand\n)\n \n{\n \n...\n \n}\n\n\n}\n\n\n\n\n\n\nStep 2. Implement each method of \nAbstractExpandableItemAdapter\n\u00b6\n\n\nImplement \ngetGroupCount()\n / \ngetChildCount()\n\u00b6\n\n\nThe corresponding \nRecyclerView.Adapter\n's method is \ngetItemCount()\n.\n\n\n@Override\n\n\npublic\n \nint\n \ngetGroupCount\n()\n \n{\n\n    \nreturn\n \nitems\n.\nsize\n();\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nint\n \ngetChildCount\n(\nint\n \ngroupPosition\n)\n \n{\n\n    \nreuturn\n \nitems\n.\nget\n(\ngroupPosition\n).\nsize\n();\n\n\n}\n\n\n\n\n\n\nImplement \ngetGroupId()\n / \ngetChildId()\n\u00b6\n\n\nThe corresponding \nRecyclerView.Adapter\n's method is \ngetItemId()\n.\n\n\n@Override\n\n\npublic\n \nint\n \ngetGroupId\n(\nint\n \ngroupPosition\n)\n \n{\n\n    \nreturn\n \nitems\n.\nget\n(\ngroupPosition\n).\nid\n;\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nint\n \ngetChildId\n(\nint\n \ngroupPosition\n,\n \nint\n \nchildPosition\n)\n \n{\n\n    \nreuturn\n \nitems\n.\nget\n(\ngroupPosition\n).\nchildren\n.\nget\n(\nchildPosition\n).\nid\n;\n\n\n}\n\n\n\n\n\n\nImplement \nonCreateGroupViewHolder()\n / \nonCreateChildViewHolder()\n\u00b6\n\n\nThe corresponding \nRecyclerView.Adapter\n's method is \nonCreateViewHolder()\n.\n\n\n@Override\n\n\npublic\n \nMyGroupVH\n \nonCreateGroupViewHolder\n(\nViewGroup\n \nparent\n,\n \nint\n \nviewType\n)\n \n{\n\n    \nView\n \nv\n \n=\n \nLayoutInfrater\n.\nfrom\n(\nparent\n.\ngetContext\n()).\ninflate\n(\nR\n.\nlayout\n.\nitem_group\n,\n \nparent\n,\n \nfalse\n);\n\n    \nreturn\n \nnew\n \nMyGroupVH\n(\nv\n);\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nMyChildViewHolder\n \nonCreateChildViewHolder\n(\nViewGroup\n \nparent\n,\n \nint\n \nviewType\n)\n \n{\n\n    \nView\n \nv\n \n=\n \nLayoutInfrater\n.\nfrom\n(\nparent\n.\ngetContext\n()).\ninflate\n(\nR\n.\nlayout\n.\nitem_child\n,\n \nparent\n,\n \nfalse\n);\n\n    \nreturn\n \nnew\n \nMyChildVH\n(\nv\n);\n\n\n}\n\n\n\n\n\n\nImplement \nonBindGroupViewHolder()\n / \nonBindChildViewHolder()\n\u00b6\n\n\nThe corresponding \nRecyclerView.Adapter\n's method is \nonBindViewHolder()\n.\n\n\n@Override\n\n\npublic\n \nvoid\n \nonBindGroupViewHolder\n(\nMyGroupVH\n \nholder\n,\n \nint\n \ngroupPosition\n,\n \nint\n \nviewType\n)\n \n{\n\n    \nMyGroupItem\n \nitem\n \n=\n \nitems\n.\nget\n(\ngroupPosition\n);\n\n    \nholder\n.\ntext\n.\nsetText\n(...);\n\n\n}\n\n\n\n@Override\n\n\npublic\n \nvoid\n \nonBindChildViewHolder\n(\nMyChildViewHolder\n \nholder\n,\n \nint\n \ngroupPosition\n,\n \nint\n \nchildPosition\n,\n \nint\n \nviewType\n)\n \n{\n\n    \nMyChildItem\n \nitem\n \n=\n \nitems\n.\nget\n(\ngroupPosition\n).\nchildren\n.\nget\n(\nchildPosition\n);\n\n    \nholder\n.\ntext\n.\nsetText\n(...);\n\n\n}\n\n\n\n\n\n\nImplement \nonCheckCanExpandOrCollapseGroup()\n\u00b6\n\n\nTODO",
            "title": "Expandable"
        },
        {
            "location": "/expandable/#tutorial",
            "text": "",
            "title": "Tutorial"
        },
        {
            "location": "/expandable/#step-1-extend-abstractexpandableitemadapter-instead-of-recyclerviewadapter",
            "text": "First, you need to extend  AbstractExpandableItemAdapter  to use expandable items feature. This class implements  RecyclerView.Adapter 's methods and some of them are sealed via  final  keyword. Instead, it provides some  Group  /  Child  prefixed version of `RecyclerView.Adapter' methods.  class   MyChildItem   { \n     public   long   id ;  }  class   MyGroupItem   { \n     public   long   id ; \n     List < MyChildItem >   children ;  }  class   MyAdapter   extends   AbstractExpandableItemAdapter < MyAdapter . MyGroupVH ,   MyAdapter . MyChildVH >   { \n     List < MyGroupItem >   items ; \n\n     public   MyAdapter ()   { \n         setHasStableIds ( true );   // this is required for expandable feature. \n     } \n\n     @Override \n     public   int   getGroupCount ()   {   ...   } \n\n     @Override \n     public   int   getChildCount ( int   groupPosition )   {   ...   } \n\n     @Override \n     public   long   getGroupId ( int   groupPosition )   {   ...   } \n\n     @Override \n     public   long   getChildId ( int   groupPosition ,   int   childPosition )   {   ...   } \n\n     @Override \n     public   MyGroupVH   onCreateGroupViewHolder ( ViewGroup   parent ,   int   viewType )   {   ...   } \n\n     @Override \n     public   MyChildViewHolder   onCreateChildViewHolder ( ViewGroup   parent ,   int   viewType )   {   ...   } \n\n     @Override \n     public   void   onBindGroupViewHolder ( MyGroupVH   holder ,   int   groupPosition ,   int   viewType )   {   ...   } \n\n     @Override \n     public   void   onBindChildViewHolder ( MyChildViewHolder   holder ,   int   groupPosition ,   int   childPosition ,   int   viewType )   {   ...   } \n\n     @Override \n     public   boolean   onCheckCanExpandOrCollapseGroup ( MyGroupVH   holder ,   int   groupPosition ,   int   x ,   int   y ,   boolean   expand )   {   ...   }  }",
            "title": "Step 1. Extend AbstractExpandableItemAdapter instead of RecyclerView.Adapter"
        },
        {
            "location": "/expandable/#step-2-implement-each-method-of-abstractexpandableitemadapter",
            "text": "",
            "title": "Step 2. Implement each method of AbstractExpandableItemAdapter"
        },
        {
            "location": "/expandable/#implement-getgroupcount-getchildcount",
            "text": "The corresponding  RecyclerView.Adapter 's method is  getItemCount() .  @Override  public   int   getGroupCount ()   { \n     return   items . size ();  }  @Override  public   int   getChildCount ( int   groupPosition )   { \n     reuturn   items . get ( groupPosition ). size ();  }",
            "title": "Implement getGroupCount() / getChildCount()"
        },
        {
            "location": "/expandable/#implement-getgroupid-getchildid",
            "text": "The corresponding  RecyclerView.Adapter 's method is  getItemId() .  @Override  public   int   getGroupId ( int   groupPosition )   { \n     return   items . get ( groupPosition ). id ;  }  @Override  public   int   getChildId ( int   groupPosition ,   int   childPosition )   { \n     reuturn   items . get ( groupPosition ). children . get ( childPosition ). id ;  }",
            "title": "Implement getGroupId() / getChildId()"
        },
        {
            "location": "/expandable/#implement-oncreategroupviewholder-oncreatechildviewholder",
            "text": "The corresponding  RecyclerView.Adapter 's method is  onCreateViewHolder() .  @Override  public   MyGroupVH   onCreateGroupViewHolder ( ViewGroup   parent ,   int   viewType )   { \n     View   v   =   LayoutInfrater . from ( parent . getContext ()). inflate ( R . layout . item_group ,   parent ,   false ); \n     return   new   MyGroupVH ( v );  }  @Override  public   MyChildViewHolder   onCreateChildViewHolder ( ViewGroup   parent ,   int   viewType )   { \n     View   v   =   LayoutInfrater . from ( parent . getContext ()). inflate ( R . layout . item_child ,   parent ,   false ); \n     return   new   MyChildVH ( v );  }",
            "title": "Implement onCreateGroupViewHolder() / onCreateChildViewHolder()"
        },
        {
            "location": "/expandable/#implement-onbindgroupviewholder-onbindchildviewholder",
            "text": "The corresponding  RecyclerView.Adapter 's method is  onBindViewHolder() .  @Override  public   void   onBindGroupViewHolder ( MyGroupVH   holder ,   int   groupPosition ,   int   viewType )   { \n     MyGroupItem   item   =   items . get ( groupPosition ); \n     holder . text . setText (...);  }  @Override  public   void   onBindChildViewHolder ( MyChildViewHolder   holder ,   int   groupPosition ,   int   childPosition ,   int   viewType )   { \n     MyChildItem   item   =   items . get ( groupPosition ). children . get ( childPosition ); \n     holder . text . setText (...);  }",
            "title": "Implement onBindGroupViewHolder() / onBindChildViewHolder()"
        },
        {
            "location": "/expandable/#implement-oncheckcanexpandorcollapsegroup",
            "text": "TODO",
            "title": "Implement onCheckCanExpandOrCollapseGroup()"
        },
        {
            "location": "/advanced-examples/",
            "text": "",
            "title": "Advanced Examples"
        },
        {
            "location": "/faq/",
            "text": "TODO\n\n\nDrag & Drop\n\u00b6\n\n\nSwipeable\n\u00b6\n\n\nUnexpected item animations\n\u00b6\n\n\n[HELP] Swipe animation not like example #199\n\n\nExpandable\n\u00b6\n\n\nClick event handling\n\u00b6\n\n\n\n\n[Expand Problem] : How to lock expanding of a specific group using onBindGroupViewHolder? #302",
            "title": "FAQ"
        },
        {
            "location": "/faq/#drag-drop",
            "text": "",
            "title": "Drag &amp; Drop"
        },
        {
            "location": "/faq/#swipeable",
            "text": "",
            "title": "Swipeable"
        },
        {
            "location": "/faq/#unexpected-item-animations",
            "text": "[HELP] Swipe animation not like example #199",
            "title": "Unexpected item animations"
        },
        {
            "location": "/faq/#expandable",
            "text": "",
            "title": "Expandable"
        },
        {
            "location": "/faq/#click-event-handling",
            "text": "[Expand Problem] : How to lock expanding of a specific group using onBindGroupViewHolder? #302",
            "title": "Click event handling"
        },
        {
            "location": "/license/",
            "text": "Copyright (C) 2015 Haruki Hasegawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.",
            "title": "License"
        },
        {
            "location": "/javadoc/",
            "text": "Redirecting...\n\u00b6",
            "title": "Javadoc"
        },
        {
            "location": "/javadoc/#redirecting",
            "text": "",
            "title": "Redirecting..."
        }
    ]
}